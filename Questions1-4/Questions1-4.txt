--[[    QUESTION 1     ]]


local function releaseStorage(player)
    
    --[[Interview Comment: Instead of setting the values between 1 and -1, we are instead
    going to figure out if the value is nil or not. By setting the value to nil instead of
    a numerical value, we are speeding up the calcualtions as well as freeing up the memory
    for more calculations and variables.]]--
    
    player:setStorageValue(1000, nil)
end
    
function onLogout(player)

    --[[Interview Comment: As stated above, now we can simply check if the value not set to
    nil. We do the same action as before with 1/-1, but change it to match our cases now.]]--
    
    if player:getStorageValue(1000) ~= nil then
    	addEvent(releaseStorage, 1000, player)
    end
    return true
end





--[[    QUESTION 2     ]]

function printSmallGuildNames(memberCount)
 
-- this method is supposed to print names of all guilds that have less than memberCount max members
 local selectGuildQuery = "SELECT name FROM guilds WHERE max_members < %d;"
 local resultId = db.storeQuery(string.format(selectGuildQuery, memberCount))

 --[[ Interview Comment: The other thing I added to this code was just some error handling. We
 have a good structure for when the query is able to find results, however we don't have any
 statements that help the user see that there were no results found. If we were to run with
 what we we're given initially, we would print out 'nil' with that edge case. We want to give 
 a more understandable message so anyone could realize what the results meant.]]--

 if not resultId then
     print("No guilds below " .. memberCount .. "could be found.")
     return
 end

  --[[ Interview Comment: I noticed there was an error when initializing this local
  variable through the previous one. Originally the code calls on "result" but we
  need to access "resultId", or else it will access nothing and ultimately result in
  a 'nil' value, which could lead to confusion for later debugging.]]--
    local guildName = resultId.getString("name")

    --[[Interview Comment: Since we would get back possibly a list of guild names from
    the query, we would want to make sure that we give it the possibility to list off
    multiple names in that edge case. This while loop would keep printing ]]--
    
    while resultId do
        local guildName = resultId.getString("name")
        print(guildName)
    end 

  --[[ Interview Comment: Finally at the end of the entire function, I added this close 
  function to the variable that holds the query from the database so that way we can close
  the cursor. By doing this, we are able to open up some memory for further query's in
  the future.]]--

  resultId.close()
end




--[[    QUESTION 3     ]]--

--[[Interview Comment: When I changed the name of the method, I choose the most rational option and renamed
the method to something as short hand as possible while trying to still convey the idea that this method's
function removes a member from the inputted player's party.]]--

function removeMemberFromParty(playerId, membername)

    --[[Interview Comment: I went ahead and declared player as a local variable in the context of this problem,
    just because we are initializing and operating on the value within this function. That way when we call on
    the party information through the player method, we don't have to worry about globally getting the player
    information again. Also, I didn't change this because technically there was not a compliation or runtime
    error, however, it would probably be best to maybe change the name of the variable from "player" when the
    constructor of the object. It can get confusing for later on when you are figuring out at first glance
    if the code is referring to which one.]]--
    
    local player = Player(playerId)

    --[[Interview Comment: Since we are comparing the value in the floor loop with the Player(membername),
    I thought it would just be better to instansiate a variable at the beginning of the function that holds
    the local value of the name and use that for a comparison to increase optimization, so that we don't have to
    keep accessing a global variable each time. Now we don't have to worry about the two other times we have to
    globally access the variable.]]--
    
    local name = Player(membername)
    local party = player:getParty()

    --[[Interview Comment: This change is actually needed for later on, but all I have done here is create a local
    variable that holds the table for party members that we fetch from party:getMembers()]]--
    local partyMembers = party:getMembers()
    
    --[[Interview Comment: Here is where the change prior is important. Instead of needing to call the function pairs()
    through every iteration of the loop, since we have instansiated the table earlier, we avoid needing to call a separate
    function by instead getting the length of the local table and iterating through this.]]--
    for k=1, #partyMembers do 

        --[[Interview Comment: From the change above, we are able to change this expression to a single variable. Instead of
        instansiating a local variable to hold the value, we can just look at table values directly while iterating. We could
        include a local variable for readability, but this solution allows for us not to worry about overinstansiating]]--
        
	if partyMembers[k] == name then
            
	    --[[Interview Comment: This is another moment within the code where we change the parameter to the single variable.]]--
            
	    party:removeMember(name)

            --[[Interview Comment: If we are assuming that the code inputs only a single member that needs to be removed, then
            once we have found the name of the member we want to remove, then we should just exit the loop so that we can reduce
            the number of times we are in the loop. If we instead assumed that we are removing a list of names, then we would need
            a second loop before the table that goes through the list of member names we want to remove, and then iterate through
            the table and remove each one.]]--
            
	    return
        end
    end
end






/* QUESTION 4 */

void Game::addItemToPlayer(const std::string& recipient, uint16_t itemId) {
    Player* player = g_game.getPlayerByName(recipient);
    if (!player) {

        /*Interview Comment: The memory leak issue beings here, with the allocation of a
        player object with no deallocation later on. This is fine if you were just going to
        use this for a single player, but if you were to open this up to multiple players,
        eventually there would be no memory left to store information.*/
        
	player = new Player(nullptr);
        if (!IOLoginData::loadPlayerByName(player, recipient)) {
            return;
        }
    }

    Item* item = Item::CreateItem(itemId);
    if (!item) {
        return;
    }

    g_game.internalAddItem(player->getInbox(), item, INDEX_WHEREEVER, FLAG_NOLIMIT);

    if (player->isOffline()) {
        IOLoginData::savePlayer(player);
    }

    /*Interview Comment: The best way to deal with this is by making sure we deallocate the
    player after we have performed all the necessary operations. We call on the delete operation
    on the player object, which will pass the object through a deconstructor and give us some memory
    to allocate for future players.*/
    
    delete player;
}